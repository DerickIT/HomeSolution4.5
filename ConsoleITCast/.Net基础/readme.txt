静态类中可以有无参构造函数，不支持有残构造函数

通过virtual，abstract，interface来实现多态
抽象方法不能有任何实现，必须包含在抽象类中

sealed密封类，类不能被继承，标记里面的方法不能重写

使用ildasm，。netreflector查看il代码

as转换时校验一次直接转换，is和（T）会通过反射校验类型两次

传递性，单根性 --类
里氏替换原则  子类转换成父类，负责转换成子类 逆变，协变

抽象类的作用是为了继承，不能被实例化

抽象对象，子类实现，具体对象，具体方法，父类
抽象类中可以有实例成员（构造函数）
接口用来处理多重继承，解决类不能多继承，目的用来实现多态

接口中的成员不能有访问修饰符，默认是public，不能有字段，可以包含方法

多态的意义：程序可扩展性，最终节省成本，提高效率。
显示实现接口，被实现的方法变成private，所以通过类对象访问不到，可以解决方法重名的问题
当一个抽象类实现接口时，如果不想把接口中的成员实现，可以把成员设置成abstract类型

接口--向上转型，子，父，爷
单一职责原则，避免定义庞大的接口，多功能接口，避免接口污染
_____________________________________________________________________
枚举都是互斥的
枚举在编译完成后都是以对应的数值常量存在

标志枚举FileInfo.Attribute          标志枚举不互斥，可以互相组合 ，以二进制存在
[Flags]
public enum meiju
{
zhn,
zzz
}
——————————————————————————————————
结构是值类型，类是引用类型，不能继承，不实现多态，可以实现接口
如果存储的数据量比较小，不需要面向对象特性可以使用结构
————————————————————————————————
数据转换
值类型转引用类型是装箱，引用类型转换成值类型是拆箱，as转换不会抛出异常
convert可以将任意类型转换成任意类型
————————————————————————————
SByte不符合cls，不符合规范就会不能跨语言跨平台
——————————————————————————————————————
值类型赋值拷贝一个副本
引用类型赋值是赋值对象的引用地址【【复制对对象的引用

复制引用和复制值，
引用类型当做参数传递，改变了对象后，如果有新的对象实例化，则不会影响到原对象

ref（按引用传递）与out
ref没有在内存中开辟新的空间，就是一个地址
值传递传递的是stack中的内容，ref传递的是stack本身的地址
对于引用类型来说，栈中存储的是堆中的地址
对于值类型来说，栈中存储的就是实际的值

不同异常不同处理方式
——————————————————————————————
可变参数 params
可变参数可以传一个参数，也可以传多个参数
如果不为可变参数传值，可变参数的数组是一个长度为0的数组，不死null


当一个方法要返回多个值时可以考虑使用out
ref主要是吧一个值带进去再带出
out方法主要是为了吧一个值带出来，不要给out值初始化，out不能把值带进去，自能带出
——————————————————————————
C#将cs编译成exe，然后clr 运行EXE由jit即时编译成il代码，根据当前机器配置，资源进行运行，跟java类似
c/c++直接将代码编译成机器码
——————————————————————————————————
字符串的一致性，不可变性（创建多大就是多大，不可变，改变的是引用的副本）,留用性
字符串池是给予字符串不可变性，s1='q',s2='q',s2='5',s1=(q)
常量和变量，常量在字符串池中
不拿原来的整合，而是开辟新的内存（拘留池）
——————————————————————————————————————
stringbuilder拼接字符串
string s=null;表示s变量没有指向任何堆内存
string s="",表示指向了一个堆内存，但是内存中存储的是一个空字符串，两个相同引用类型的变量在一个引用的字符串池中
string.empty()==public static readonly string empty,，每次就不需要在开辟新内存，直接调用的是这个
字符串长度为0，就表示字符串为空
字符串拼接，翻转，分割，split
判断两个变量是不是一个对象-》栈中的变量共同指向堆里面的同一个内存
使用即时窗口，&变量名,ctrl+d+i
equals被子类重写，string比较的是值，而不是堆中的引用位置，可以使用object.ReferenceEquals()，判断对象是否相等
值类型比较的是类型，然后再是值
垃圾回收目的：提高内存利用率，只回收托管堆中的内存成员，不回收其他资源（数据库连接，文件，网络端口）
什么对象会回收：没有变量引用的对象，层级回收，所有变量初始化时都是0代内存，然后第一次回收时还引用的变量会变成第1代，当1代满了回收1代时，还在引用的会升到2代。
。net垃圾回收机制：标志和压缩
Dsipose释放除内存外的其他资源，比析构函数要好
~class(){}  析构函数和类名一致~，释放资源，当前对象被垃圾回收之前调用Finalize（），释放其他资源
WeakReference弱引用，（当需要回收后还想调用的变量）一般用在创建时比较耗时的对象，还可以用
创建一个变量，当经常用到，可以标注为若引用，标注之后用还可以用，不用就会被gc回收
——————————————————————————————————————————
arraylist用list替换，hashtable用dictionary替代
容量 arrarlist.capacity(),list是翻倍增长，array是被动增长
hashtable键值对形式
通过泛型可以限制对象的类型
KeyValuePair键值同时遍历类型
var类型推断，是强类型（在程序编译时已经替换成了相应的类型）
——————————————————————————————————
自定义泛型，约束是为了能更广的使用
path类中方法都是对获取的字符串操作，不是整个文件提供了获取文件名，后缀等方法
压缩包在查看时其实已经解压到一个临时目录下
递归-实现自己调用自己，知道资源耗尽或者判断达到临界值
操作文本文件，读取时和操作是编码格式不一致就会出现乱码
字符编码：gb2312，utf—8（国际码表英1，汉3），Unicode
 //file类判断文件是否存在，directory判断文件夹是否存在